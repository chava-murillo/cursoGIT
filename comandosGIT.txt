#CONFIGURAR CREDENCIALES DE GIT EN EQUIPO 
git config --global user.name "Nombre"
git config --global user.email "Correo"

##COMANDOS GIT EN OH-MY-ZSH
Agregar archivos a staggin
ga   git add
gaa  git add --all

 Branch
gb   git branch    //Muestra Ramas Locales
gba  git branch -a //Muestra todas las ramas
gbd  git branch -d <nombre_rama> //Eliminar una rama

#CREAR RAMAS
gb <Nombre Rama>  //Crea Rama Local a partir de Master

#CREAR RAMA Y CAMBIAR DESDE UN INICIO
gco -b <NOMBRE_RAMA>
gsw -c <NOMBRE_RAMA>

gsw - //Cambia a la rama anterior
 Commit
gcmsg git commit -m

##CAMBIAR MENSAJE DE COMMIT ANTERIOR
gc! -m (git commit --amend -m)

##RESTAURAR CAMBIOS Y COMMIT
git reset --soft HEAD^ //Va apuntar hacia al ultimo commit

--Se puede modificar el archivo--
git commit -am "Mensaje de commit" //Se actualiza mensaje del commit creado anteriormente

######### USAR PARA ELIMINAR ALGUNOS COMMIT, MIXED 
git reset --mixed <id_commit> //Va apuntar hacia el id_commit SIN borrar los archivos nuevos, solo los saca del staged
git reset --hard <id_commit> //Va colocar el HEAD en ese punto

 Checkout
gcm  git checkout $(git_main_branch)
gco  git checkout

grh  git reset HEAD <Nombre del archivo> //Sacar del staged y mandar a unstaged
//NECESITA ESTAR EN UNSTAGED 
gco -- <Nombre del archivo>//Regresa los archivos al commit anterior


 Log
glg  git log --stat
glgg git log --graph
glo  git log --oneline --decorate
glog git log --oneline --decorate --graph
gloga git log --oneline --decorate --graph --all

 Status
gsb  git status -s -b (Short y Branch)
gst  git status
gss  git status -s

#ELIMINAR COMMIT O APUNTAR HACIA COMMIT ANTERIOR
git reset --hard <id_commit>

#VOLVER A UN COMMIT FUTURO O ELIMINADO
git reflog
Copiamos id_commit
git reset --hard <id_commit>

##ETIQUETAS (TAGS)
Si queremos colocar a etiquetas a versiones alpha, beta, release, etc, se hace de la siguiente manera:

git tag -a <version> -m <Mensaje sobre la version" //La version puede ser tanto en numero como letras ejemplo: v1.0.1, Alpha, etc.

Esto le colocara la etiqueta al ultimo commit, en cambio si queremos etiquetar un commit pasado debemos de colocar lo siguiente

git tag -a <version> <id_commit> -m <Mensaje sobre la version"

##STASH
Sirve para dejar un trabajo (de la rama) pendiente por algo de emergencia, se usa de la siguiente manera:
Si queremos un Stash espcifico indicar "stash@{n}" despues del comando drop, apply, pop.

gsta git stash //Esto manda los ultimos cambios guardados al stash (pueden existir varios) se crea un WIP (Work In Progress)
gsta -m "Mensaje"
Se trabaja en lo urgente, se hace el commit de lo urgente.

::LIST
Para ver la lista de los stash que existen hacemos lo siguiente:
gstl git stash list

Despues para volver a unir los cambios que ya habiamos realizado hacemos lo siguiente:

::POP (BORRA EL STASH)
gstp git stash pop //Esto traera los cambios que existen entre el ultimo WIP y del HEAD del commit:

1.NO HAY CONFLICTOS: Hara el merge sin problema y BORRARA el stash.
2.SI HAY CONFLICTOS: Si hay conflictos entre archivos se mostraran, se corrigen pero hay que ELIMINAR el stash con drop.

::APPLY (NO BORRA EL STASH)
gstaa git stash apply //Trae los cambios en el ultimo stash y los une con el head de la lista de commit
gstaa "stash{n}" //Trae los cambios del stash{n} y los une con el head de la lista de commit

::DROP
Para eliminar los stash se puede hacer con lo siguiente:
gstd git stash drop //Elimina el stash{0}
gstd "stash{n}" //Elimina el stash{n}
gstc git stash clear //Elimina todos los stash que existan

::SHOW
 El comando show nos muestra informaciÃ³n acerca de los cambios
 gsts git stash show //Muestra diferencias de manera corta
 gsts -p //Muestra todas las diferencias

::Untracked Files
Poedemos hacer stash a archivos mixto con y sin seguimiento, para esto hacemos uso de:
gstu git stash --include--untracked
gstu -m "Mensaje"

##RENOMBRAR ARCHIVOS FUERA DE GIT
Si cambiamos el nombre de un archivo fuera de git y hacemos un gss veremos dos archivos
 D historia/superman.historia.md //original BORRADO
?? historia/superman.md          //renombrado

Tenemos que hacer un git add -u (gau) para actualizar los archivos, despues un git add -A (gaa), si volvemos a hacer un git status veremos que ya lo marca como renombrado
R  historia/superman.historia.md -> historia/superman.md

#RECUPERAR ARCHIVOS BORRADOS DE GIT
Para recuperar un archivo ya eliminado del directorio, que haya pasado por
stagging area, usamos el siguiente comando para buscar archivos eliminados en git

git log --oneline --name--status --diff-filter=D

Despues copiamos el identificador del commit que queramos recuperar
y escribimos el siguiente comando:

git checkout <id_commit>^ <nombnre_directorio> o <nombre_archivo>

#CREAR NUEVOS ALIAS
Revisar alias globales creados
git config --global -e (editar)
git config --global -l (mostrar)

Para crear alias globales escribimos lo siguiente:
git config --global alias.<nombre del alias> "Comando que deseamos hacer alias"
ejemplo:
git config --global alias.logp "log --oneline --pretty --all --graph"
para usarlo:
git logp

----GITHUB-----

#CHECAR RAMAS REMOTAS
git  remote -v //Muestra ramas remotas
gr   git remote


#CREAR RAMAS REMOTAS NUEVAS
gra git remote add <NOMBRE DEL REMOTO> <URL_REPO_GITHUB>

#PUSH
gp git push

#ENVIAR TODAS LAS RAMAS AL REMOTO
git push -u <NOMBRE DEL REMOTO> --all

#ELIMINAR RAMAS REMOTAS
git push <NOMBRE DEL REMOTO> :<NOMBRE DE LA RAMA> (1ra Manera)
git push -d <NOMBRE DEL REMOTO> <NOMBRE DE LA RAMA> (2da Manera)

<<Se puede renombrar rama principal remota desde los ajustes de github, despues se puede eliminar la rama principal, verificar que el head no apunte hacia el main con:
git remote show <NOMBRE DEL REMOTO>





 