#CONFIGURAR CREDENCIALES DE GIT EN EQUIPO 
git config --global user.name "Nombre"
git config --global user.email "Correo"

##COMANDOS GIT EN OH-MY-ZSH
Agregar archivos a staggin
ga   git add
gaa  git add --all

 Branch
gb   git branch    //Muestra Ramas Locales
gba  git branch -a //Muestra todas las ramas
gbd  git branch -d <nombre_rama> //Eliminar una rama

#CREAR RAMAS
gb <Nombre Rama>  //Crea Rama Local a partir de Master

#CREAR RAMA Y CAMBIAR DESDE UN INICIO
gco -b <NOMBRE_RAMA>
gsw -c <NOMBRE_RAMA>

gsw - //Cambia a la rama anterior
 Commit
gcmsg git commit -m

##CAMBIAR MENSAJE DE COMMIT ANTERIOR
gc! -m (git commit --amend -m)

##RESTAURAR CAMBIOS Y COMMIT
git reset --soft HEAD^ //Va apuntar hacia al ultimo commit
--Se puede modificar el archivo--
git commit -am "Mensaje de commit" //Se actualiza mensaje del commit creado anteriormente

 Checkout
gcm  git checkout $(git_main_branch)
gco  git checkout

grh  git reset HEAD <Nombre del archivo> //Sacar del staged y mandar a unstaged
//NECESITA ESTAR EN UNSTAGED 
gco -- <Nombre del archivo>//Regresa los archivos al commit anterior


 Log
glg  git log --stat
glgg git log --graph
glo  git log --oneline --decorate
glog git log --oneline --decorate --graph
gloga git log --oneline --decorate --graph --all

 Status
gsb  git status -s -b (Short y Branch)
gst  git status
gss  git status -s

#ELIMINAR COMMIT O APUNTAR HACIA COMMIT ANTERIOR
git reset --hard <id_commit>

#VOLVER A UN COMMIT FUTURO O ELIMINADO
git reflog
Copiamos id_commit
git reset --hard <id_commit>

##ETIQUETAS (TAGS)
Si queremos colocar a etiquetas a versiones alpha, beta, release, etc, se hace de la siguiente manera:

git tag -a <version> -m <Mensaje sobre la version" //La version puede ser tanto en numero como letras ejemplo: v1.0.1, Alpha, etc.

Esto le colocara la etiqueta al ultimo commit, en cambio si queremos etiquetar un commit pasado debemos de colocar lo siguiente

git tag -a <version> <id_commit> -m <Mensaje sobre la version"

##RENOMBRAR ARCHIVOS FUERA DE GIT
Si cambiamos el nombre de un archivo fuera de git y hacemos un gss veremos dos archivos
 D historia/superman.historia.md //original BORRADO
?? historia/superman.md          //renombrado

Tenemos que hacer un git add -u (gau) para actualizar los archivos, despues un git add -A (gaa), si volvemos a hacer un git status veremos que ya lo marca como renombrado
R  historia/superman.historia.md -> historia/superman.md

#RECUPERAR ARCHIVOS BORRADOS DE GIT
Para recuperar un archivo ya eliminado del directorio, que haya pasado por
stagging area, usamos el siguiente comando para buscar archivos eliminados en git

git log --oneline --name--status --diff-filter=D

Despues copiamos el identificador del commit que queramos recuperar
y escribimos el siguiente comando:

git checkout <id_commit>^ <nombnre_directorio> o <nombre_archivo>

#CREAR NUEVOS ALIAS
Revisar alias globales creados
git config --global -e (editar)
git config --global -l (mostrar)

Para crear alias globales escribimos lo siguiente:
git config --global alias.<nombre del alias> "Comando que deseamos hacer alias"
ejemplo:
git config --global alias.logp "log --oneline --pretty --all --graph"
para usarlo:
git logp

----GITHUB-----

#CHECAR RAMAS REMOTAS
git  remote -v //Muestra ramas remotas
gr   git remote


#CREAR RAMAS REMOTAS NUEVAS
gra git remote add <NOMBRE DEL REMOTO> <URL_REPO_GITHUB>

#PUSH
gp git push

#ENVIAR TODAS LAS RAMAS AL REMOTO
git push -u <NOMBRE DEL REMOTO> --all

#ELIMINAR RAMAS REMOTAS
git push <NOMBRE DEL REMOTO> :<NOMBRE DE LA RAMA> (1ra Manera)
git push -d <NOMBRE DEL REMOTO> <NOMBRE DE LA RAMA> (2da Manera)

<<Se puede renombrar rama principal remota desde los ajustes de github, despues se puede eliminar la rama principal, verificar que el head no apunte hacia el main con:
git remote show <NOMBRE DEL REMOTO>





 